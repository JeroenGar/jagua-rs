(function() {
    var type_impls = Object.fromEntries([["ndarray",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#304-862\">Source</a><a href=\"#impl-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, D&gt; <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, D&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"ndarray/trait.Dimension.html\" title=\"trait ndarray::Dimension\">Dimension</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.move_into\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#325-339\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.move_into\" class=\"fn\">move_into</a>&lt;'a, AM&gt;(self, new_array: AM)<div class=\"where\">where\n    AM: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html\" title=\"trait core::convert::Into\">Into</a>&lt;<a class=\"type\" href=\"ndarray/type.ArrayViewMut.html\" title=\"type ndarray::ArrayViewMut\">ArrayViewMut</a>&lt;'a, A, D&gt;&gt;,\n    A: 'a,</div></h4></section></summary><div class=\"docblock\"><p>Move all elements from self into <code>new_array</code>, which must be of the same shape but\ncan have a different memory layout. The destination is overwritten completely.</p>\n<p>The destination should be a mut reference to an array or an <code>ArrayViewMut</code> with\n<code>A</code> elements.</p>\n<p><em><strong>Panics</strong></em> if the shapes don‚Äôt agree.</p>\n<h6 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">¬ß</a>Example</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::Array;\n\n<span class=\"comment\">// Usage example of move_into in safe code\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array::default((<span class=\"number\">10</span>, <span class=\"number\">10</span>));\n<span class=\"kw\">let </span>b = Array::from_shape_fn((<span class=\"number\">10</span>, <span class=\"number\">10</span>), |(i, j)| (i + j).to_string());\nb.move_into(<span class=\"kw-2\">&amp;mut </span>a);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.move_into_uninit\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#378-385\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.move_into_uninit\" class=\"fn\">move_into_uninit</a>&lt;'a, AM&gt;(self, new_array: AM)<div class=\"where\">where\n    AM: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html\" title=\"trait core::convert::Into\">Into</a>&lt;<a class=\"type\" href=\"ndarray/type.ArrayViewMut.html\" title=\"type ndarray::ArrayViewMut\">ArrayViewMut</a>&lt;'a, <a class=\"union\" href=\"https://doc.rust-lang.org/1.90.0/core/mem/maybe_uninit/union.MaybeUninit.html\" title=\"union core::mem::maybe_uninit::MaybeUninit\">MaybeUninit</a>&lt;A&gt;, D&gt;&gt;,\n    A: 'a,</div></h4></section></summary><div class=\"docblock\"><p>Move all elements from self into <code>new_array</code>, which must be of the same shape but\ncan have a different memory layout. The destination is overwritten completely.</p>\n<p>The destination should be a mut reference to an array or an <code>ArrayViewMut</code> with\n<code>MaybeUninit&lt;A&gt;</code> elements (which are overwritten without dropping any existing value).</p>\n<p>Minor implementation note: Owned arrays like <code>self</code> may be sliced in place and own elements\nthat are not part of their active view; these are dropped at the end of this function,\nafter all elements in the ‚Äúactive view‚Äù are moved into <code>new_array</code>. If there is a panic in\ndrop of any such element, other elements may be leaked.</p>\n<p><em><strong>Panics</strong></em> if the shapes don‚Äôt agree.</p>\n<h6 id=\"example-1\"><a class=\"doc-anchor\" href=\"#example-1\">¬ß</a>Example</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::Array;\n\n<span class=\"kw\">let </span>a = Array::from_iter(<span class=\"number\">0</span>..<span class=\"number\">100</span>).into_shape_with_order((<span class=\"number\">10</span>, <span class=\"number\">10</span>)).unwrap();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>b = Array::uninit((<span class=\"number\">10</span>, <span class=\"number\">10</span>));\na.move_into_uninit(<span class=\"kw-2\">&amp;mut </span>b);\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// we can now promise we have fully initialized `b`.\n    </span><span class=\"kw\">let </span>b = b.assume_init();\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.push\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#545-552\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.push\" class=\"fn\">push</a>(\n    &amp;mut self,\n    axis: <a class=\"struct\" href=\"ndarray/struct.Axis.html\" title=\"struct ndarray::Axis\">Axis</a>,\n    array: <a class=\"type\" href=\"ndarray/type.ArrayView.html\" title=\"type ndarray::ArrayView\">ArrayView</a>&lt;'_, A, D::<a class=\"associatedtype\" href=\"ndarray/trait.Dimension.html#associatedtype.Smaller\" title=\"type ndarray::Dimension::Smaller\">Smaller</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    D: <a class=\"trait\" href=\"ndarray/trait.RemoveAxis.html\" title=\"trait ndarray::RemoveAxis\">RemoveAxis</a>,</div></h4></section></summary><div class=\"docblock\"><p>Append an array to the array along an axis.</p>\n<p>The elements of <code>array</code> are cloned and extend the axis <code>axis</code> in the present array;\n<code>self</code> will grow in size by 1 along <code>axis</code>.</p>\n<p>Append to the array, where the array being pushed to the array has one dimension less than\nthe <code>self</code> array. This method is equivalent to <a href=\"ndarray/struct.ArrayBase.html#method.append\" title=\"method ndarray::ArrayBase::append\">append</a> in this way:\n<code>self.append(axis, array.insert_axis(axis))</code>.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the shape of self does not match the array-to-append;\nall axes <em>except</em> the axis along which it being appended matter for this check:\nthe shape of <code>self</code> with <code>axis</code> removed must be the same as the shape of <code>array</code>.</p>\n<p>The memory layout of the <code>self</code> array matters for ensuring that the append is efficient.\nAppending automatically changes memory layout of the array so that it is appended to\nalong the ‚Äúgrowing axis‚Äù. However, if the memory layout needs adjusting, the array must\nreallocate and move memory.</p>\n<p>The operation leaves the existing data in place and is most efficent if <code>axis</code> is a\n‚Äúgrowing axis‚Äù for the array, i.e. one of these is true:</p>\n<ul>\n<li>The axis is the longest stride axis, for example the 0th axis in a C-layout or the\n<em>n-1</em>th axis in an F-layout array.</li>\n<li>The axis has length 0 or 1 (It is converted to the new growing axis)</li>\n</ul>\n<p>Ensure appending is efficient by for example starting from an empty array and/or always\nappending to an array along the same axis.</p>\n<p>The amortized average complexity of the append, when appending along its growing axis, is\nO(<em>m</em>) where <em>m</em> is the number of individual elements to append.</p>\n<p>The memory layout of the argument <code>array</code> does not matter to the same extent.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{Array, ArrayView, array, Axis};\n\n<span class=\"comment\">// create an empty array and push rows to it\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array::zeros((<span class=\"number\">0</span>, <span class=\"number\">4</span>));\n<span class=\"kw\">let </span>ones  = ArrayView::from(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1.</span>; <span class=\"number\">4</span>]);\n<span class=\"kw\">let </span>zeros = ArrayView::from(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">0.</span>; <span class=\"number\">4</span>]);\na.push(Axis(<span class=\"number\">0</span>), ones).unwrap();\na.push(Axis(<span class=\"number\">0</span>), zeros).unwrap();\na.push(Axis(<span class=\"number\">0</span>), ones).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(\n    a,\n    <span class=\"macro\">array!</span>[[<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>],\n           [<span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>],\n           [<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.append\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#604-797\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.append\" class=\"fn\">append</a>(\n    &amp;mut self,\n    axis: <a class=\"struct\" href=\"ndarray/struct.Axis.html\" title=\"struct ndarray::Axis\">Axis</a>,\n    array: <a class=\"type\" href=\"ndarray/type.ArrayView.html\" title=\"type ndarray::ArrayView\">ArrayView</a>&lt;'_, A, D&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    D: <a class=\"trait\" href=\"ndarray/trait.RemoveAxis.html\" title=\"trait ndarray::RemoveAxis\">RemoveAxis</a>,</div></h4></section></summary><div class=\"docblock\"><p>Append an array to the array along an axis.</p>\n<p>The elements of <code>array</code> are cloned and extend the axis <code>axis</code> in the present array;\n<code>self</code> will grow in size by <code>array.len_of(axis)</code> along <code>axis</code>.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the shape of self does not match the array-to-append;\nall axes <em>except</em> the axis along which it being appended matter for this check:\nthe shape of <code>self</code> with <code>axis</code> removed must be the same as the shape of <code>array</code> with\n<code>axis</code> removed.</p>\n<p>The memory layout of the <code>self</code> array matters for ensuring that the append is efficient.\nAppending automatically changes memory layout of the array so that it is appended to\nalong the ‚Äúgrowing axis‚Äù. However, if the memory layout needs adjusting, the array must\nreallocate and move memory.</p>\n<p>The operation leaves the existing data in place and is most efficent if <code>axis</code> is a\n‚Äúgrowing axis‚Äù for the array, i.e. one of these is true:</p>\n<ul>\n<li>The axis is the longest stride axis, for example the 0th axis in a C-layout or the\n<em>n-1</em>th axis in an F-layout array.</li>\n<li>The axis has length 0 or 1 (It is converted to the new growing axis)</li>\n</ul>\n<p>Ensure appending is efficient by for example starting from an empty array and/or always\nappending to an array along the same axis.</p>\n<p>The amortized average complexity of the append, when appending along its growing axis, is\nO(<em>m</em>) where <em>m</em> is the number of individual elements to append.</p>\n<p>The memory layout of the argument <code>array</code> does not matter to the same extent.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{Array, ArrayView, array, Axis};\n\n<span class=\"comment\">// create an empty array and append two rows at a time\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array::zeros((<span class=\"number\">0</span>, <span class=\"number\">4</span>));\n<span class=\"kw\">let </span>ones  = ArrayView::from(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1.</span>; <span class=\"number\">8</span>]).into_shape_with_order((<span class=\"number\">2</span>, <span class=\"number\">4</span>)).unwrap();\n<span class=\"kw\">let </span>zeros = ArrayView::from(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">0.</span>; <span class=\"number\">8</span>]).into_shape_with_order((<span class=\"number\">2</span>, <span class=\"number\">4</span>)).unwrap();\na.append(Axis(<span class=\"number\">0</span>), ones).unwrap();\na.append(Axis(<span class=\"number\">0</span>), zeros).unwrap();\na.append(Axis(<span class=\"number\">0</span>), ones).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(\n    a,\n    <span class=\"macro\">array!</span>[[<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>],\n           [<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>],\n           [<span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>],\n           [<span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>, <span class=\"number\">0.</span>],\n           [<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>],\n           [<span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>, <span class=\"number\">1.</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#823-861\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.reserve\" class=\"fn\">reserve</a>(\n    &amp;mut self,\n    axis: <a class=\"struct\" href=\"ndarray/struct.Axis.html\" title=\"struct ndarray::Axis\">Axis</a>,\n    additional: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"ndarray/trait.RemoveAxis.html\" title=\"trait ndarray::RemoveAxis\">RemoveAxis</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reserve capacity to grow array along <code>axis</code> by at least <code>additional</code> elements.</p>\n<p>The axis should be in the range <code>Axis(</code> 0 .. <em>n</em> <code>)</code> where <em>n</em> is the\nnumber of dimensions (axes) of the array.</p>\n<p>Existing elements of <code>array</code> are untouched and the backing storage is grown by\ncalling the underlying <code>reserve</code> method of the <code>OwnedRepr</code>.</p>\n<p>This is useful when pushing or appending repeatedly to an array to avoid multiple\nallocations.</p>\n<p><em><strong>Panics</strong></em> if the axis is out of bounds.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the resultant capacity is larger than the addressable\nbounds; that is, the product of non-zero axis lengths once <code>axis</code> has been extended by\n<code>additional</code> exceeds <code>isize::MAX</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{Array3, Axis};\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array3::&lt;i32&gt;::zeros((<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>));\na.reserve(Axis(<span class=\"number\">0</span>), <span class=\"number\">1000</span>).unwrap();\n<span class=\"macro\">assert!</span>(a.into_raw_vec().capacity() &gt;= <span class=\"number\">2</span><span class=\"kw-2\">*</span><span class=\"number\">4</span><span class=\"kw-2\">*</span><span class=\"number\">1000</span>);</code></pre></div>\n</div></details></div></details>",0,"ndarray::aliases::Array0","ndarray::aliases::Array1","ndarray::aliases::Array2","ndarray::aliases::Array3","ndarray::aliases::Array4","ndarray::aliases::Array5","ndarray::aliases::Array6","ndarray::aliases::ArrayD"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#61-160\">Source</a><a href=\"#impl-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, D&gt; <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, D&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"ndarray/trait.Dimension.html\" title=\"trait ndarray::Dimension\">Dimension</a>,</div></h3><div class=\"docblock\"><p>Methods specific to <code>Array</code>.</p>\n</div></section></summary><div class=\"docblock\"><p><em><strong>See also all methods for <a href=\"ndarray/struct.ArrayBase.html\" title=\"struct ndarray::ArrayBase\"><code>ArrayBase</code></a></strong></em></p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw_vec_and_offset\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#143-147\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.into_raw_vec_and_offset\" class=\"fn\">into_raw_vec_and_offset</a>(self) -&gt; (<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;A&gt;, <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt;)</h4></section></summary><div class=\"docblock\"><p>Return a vector of the elements in the array, in the way they are\nstored internally, and the index in the vector corresponding to the\nlogically first element of the array (or None if the array is empty).</p>\n<p>If the array is in standard memory layout, the logical element order\nof the array (<code>.iter()</code> order) and of the returned vector will be the same.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{array, Array2, Axis};\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>arr: Array2&lt;f64&gt; = <span class=\"macro\">array!</span>[[<span class=\"number\">1.</span>, <span class=\"number\">2.</span>], [<span class=\"number\">3.</span>, <span class=\"number\">4.</span>], [<span class=\"number\">5.</span>, <span class=\"number\">6.</span>]];\narr.slice_axis_inplace(Axis(<span class=\"number\">0</span>), (<span class=\"number\">1</span>..).into());\n<span class=\"macro\">assert_eq!</span>(arr[[<span class=\"number\">0</span>, <span class=\"number\">0</span>]], <span class=\"number\">3.</span>);\n<span class=\"kw\">let </span>copy = arr.clone();\n\n<span class=\"kw\">let </span>shape = arr.shape().to_owned();\n<span class=\"kw\">let </span>strides = arr.strides().to_owned();\n<span class=\"kw\">let </span>(v, offset) = arr.into_raw_vec_and_offset();\n\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1.</span>, <span class=\"number\">2.</span>, <span class=\"number\">3.</span>, <span class=\"number\">4.</span>, <span class=\"number\">5.</span>, <span class=\"number\">6.</span>]);\n<span class=\"macro\">assert_eq!</span>(offset, <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(v[offset.unwrap()], <span class=\"number\">3.</span>);\n<span class=\"kw\">for </span>row <span class=\"kw\">in </span><span class=\"number\">0</span>..shape[<span class=\"number\">0</span>] {\n    <span class=\"kw\">for </span>col <span class=\"kw\">in </span><span class=\"number\">0</span>..shape[<span class=\"number\">1</span>] {\n        <span class=\"kw\">let </span>index = (\n            offset.unwrap() <span class=\"kw\">as </span>isize\n            + row <span class=\"kw\">as </span>isize * strides[<span class=\"number\">0</span>]\n            + col <span class=\"kw\">as </span>isize * strides[<span class=\"number\">1</span>]\n        ) <span class=\"kw\">as </span>usize;\n        <span class=\"macro\">assert_eq!</span>(v[index], copy[[row, col]]);\n    }\n}</code></pre></div>\n<p>In the case of zero-sized elements, the offset to the logically first\nelement is somewhat meaningless. For convenience, an offset will be\nreturned such that all indices computed using the offset, shape, and\nstrides will be in-bounds for the <code>Vec&lt;A&gt;</code>. Note that this offset won‚Äôt\nnecessarily be the same as the offset for an array of nonzero-sized\nelements sliced in the same way.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{array, Array2, Axis};\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>arr: Array2&lt;()&gt; = <span class=\"macro\">array!</span>[[(), ()], [(), ()], [(), ()]];\narr.slice_axis_inplace(Axis(<span class=\"number\">0</span>), (<span class=\"number\">1</span>..).into());\n\n<span class=\"kw\">let </span>shape = arr.shape().to_owned();\n<span class=\"kw\">let </span>strides = arr.strides().to_owned();\n<span class=\"kw\">let </span>(v, offset) = arr.into_raw_vec_and_offset();\n\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[(), (), (), (), (), ()]);\n<span class=\"kw\">for </span>row <span class=\"kw\">in </span><span class=\"number\">0</span>..shape[<span class=\"number\">0</span>] {\n    <span class=\"kw\">for </span>col <span class=\"kw\">in </span><span class=\"number\">0</span>..shape[<span class=\"number\">1</span>] {\n        <span class=\"kw\">let </span>index = (\n            offset.unwrap() <span class=\"kw\">as </span>isize\n            + row <span class=\"kw\">as </span>isize * strides[<span class=\"number\">0</span>]\n            + col <span class=\"kw\">as </span>isize * strides[<span class=\"number\">1</span>]\n        ) <span class=\"kw\">as </span>usize;\n        <span class=\"macro\">assert_eq!</span>(v[index], ());\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw_vec\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#156-159\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.into_raw_vec\" class=\"fn\">into_raw_vec</a>(self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;A&gt;</h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">üëé</span><span>Deprecated since 0.16.0: Use .into_raw_vec_and_offset() instead</span></div></span></summary><div class=\"docblock\"><p>Return a vector of the elements in the array, in the way they are\nstored internally.</p>\n<p>Depending on slicing and strides, the logically first element of the\narray can be located at an offset. Because of this, prefer to use\n<code>.into_raw_vec_and_offset()</code> instead.</p>\n</div></details></div></details>",0,"ndarray::aliases::Array0","ndarray::aliases::Array1","ndarray::aliases::Array2","ndarray::aliases::Array3","ndarray::aliases::Array4","ndarray::aliases::Array5","ndarray::aliases::Array6","ndarray::aliases::ArrayD"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+0%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#22-56\">Source</a><a href=\"#impl-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+0%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix0.html\" title=\"type ndarray::Ix0\">Ix0</a>&gt;</h3><div class=\"docblock\"><p>Methods specific to <code>Array0</code>.</p>\n</div></section></summary><div class=\"docblock\"><p><em><strong>See also all methods for <a href=\"ndarray/struct.ArrayBase.html\" title=\"struct ndarray::ArrayBase\"><code>ArrayBase</code></a></strong></em></p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_scalar\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#37-55\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.into_scalar\" class=\"fn\">into_scalar</a>(self) -&gt; A</h4></section></summary><div class=\"docblock\"><p>Returns the single element in the array without cloning it.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{arr0, Array0};\n\n<span class=\"comment\">// `Foo` doesn't implement `Clone`.\n</span><span class=\"attr\">#[derive(Debug, Eq, PartialEq)]\n</span><span class=\"kw\">struct </span>Foo;\n\n<span class=\"kw\">let </span>array: Array0&lt;Foo&gt; = arr0(Foo);\n<span class=\"kw\">let </span>scalar: Foo = array.into_scalar();\n<span class=\"macro\">assert_eq!</span>(scalar, Foo);</code></pre></div>\n</div></details></div></details>",0,"ndarray::aliases::Array0"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+2%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#165-302\">Source</a><a href=\"#impl-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+2%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A&gt; <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix2.html\" title=\"type ndarray::Ix2\">Ix2</a>&gt;</h3><div class=\"docblock\"><p>Methods specific to <code>Array2</code>.</p>\n</div></section></summary><div class=\"docblock\"><p><em><strong>See also all methods for <a href=\"ndarray/struct.ArrayBase.html\" title=\"struct ndarray::ArrayBase\"><code>ArrayBase</code></a></strong></em></p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.push_row\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#206-210\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.push_row\" class=\"fn\">push_row</a>(&amp;mut self, row: <a class=\"type\" href=\"ndarray/type.ArrayView.html\" title=\"type ndarray::ArrayView\">ArrayView</a>&lt;'_, A, <a class=\"type\" href=\"ndarray/type.Ix1.html\" title=\"type ndarray::Ix1\">Ix1</a>&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Append a row to an array</p>\n<p>The elements from <code>row</code> are cloned and added as a new row in the array.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the length of the row does not match the length of the\nrows in the array.</p>\n<p>The memory layout of the <code>self</code> array matters for ensuring that the append is efficient.\nAppending automatically changes memory layout of the array so that it is appended to\nalong the ‚Äúgrowing axis‚Äù. However, if the memory layout needs adjusting, the array must\nreallocate and move memory.</p>\n<p>The operation leaves the existing data in place and is most efficent if one of these is\ntrue:</p>\n<ul>\n<li>The axis being appended to is the longest stride axis, i.e the array is in row major\n(‚ÄúC‚Äù) layout.</li>\n<li>The array has 0 or 1 rows (It is converted to row major)</li>\n</ul>\n<p>Ensure appending is efficient by, for example, appending to an empty array and then always\npushing/appending along the same axis. For pushing rows, ndarray‚Äôs default layout (C order)\nis efficient.</p>\n<p>When repeatedly appending to a single axis, the amortized average complexity of each\nappend is O(m), where <em>m</em> is the length of the row.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{Array, ArrayView, array};\n\n<span class=\"comment\">// create an empty array and append\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array::zeros((<span class=\"number\">0</span>, <span class=\"number\">4</span>));\na.push_row(ArrayView::from(<span class=\"kw-2\">&amp;</span>[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>])).unwrap();\na.push_row(ArrayView::from(<span class=\"kw-2\">&amp;</span>[-<span class=\"number\">1.</span>, -<span class=\"number\">2.</span>, -<span class=\"number\">3.</span>, -<span class=\"number\">4.</span>])).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(\n    a,\n    <span class=\"macro\">array!</span>[[ <span class=\"number\">1.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">4.</span>],\n           [-<span class=\"number\">1.</span>, -<span class=\"number\">2.</span>, -<span class=\"number\">3.</span>, -<span class=\"number\">4.</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.push_column\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#251-255\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.push_column\" class=\"fn\">push_column</a>(\n    &amp;mut self,\n    column: <a class=\"type\" href=\"ndarray/type.ArrayView.html\" title=\"type ndarray::ArrayView\">ArrayView</a>&lt;'_, A, <a class=\"type\" href=\"ndarray/type.Ix1.html\" title=\"type ndarray::Ix1\">Ix1</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Append a column to an array</p>\n<p>The elements from <code>column</code> are cloned and added as a new column in the array.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the length of the column does not match the length of\nthe columns in the array.</p>\n<p>The memory layout of the <code>self</code> array matters for ensuring that the append is efficient.\nAppending automatically changes memory layout of the array so that it is appended to\nalong the ‚Äúgrowing axis‚Äù. However, if the memory layout needs adjusting, the array must\nreallocate and move memory.</p>\n<p>The operation leaves the existing data in place and is most efficent if one of these is\ntrue:</p>\n<ul>\n<li>The axis being appended to is the longest stride axis, i.e the array is in column major\n(‚ÄúF‚Äù) layout.</li>\n<li>The array has 0 or 1 columns (It is converted to column major)</li>\n</ul>\n<p>Ensure appending is efficient by, for example, appending to an empty array and then always\npushing/appending along the same axis. For pushing columns, column major layout (F order)\nis efficient.</p>\n<p>When repeatedly appending to a single axis, the amortized average complexity of each append\nis O(m), where <em>m</em> is the length of the column.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::{Array, ArrayView, array};\n\n<span class=\"comment\">// create an empty array and append\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array::zeros((<span class=\"number\">2</span>, <span class=\"number\">0</span>));\na.push_column(ArrayView::from(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1.</span>, <span class=\"number\">2.</span>])).unwrap();\na.push_column(ArrayView::from(<span class=\"kw-2\">&amp;</span>[-<span class=\"number\">1.</span>, -<span class=\"number\">2.</span>])).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(\n    a,\n    <span class=\"macro\">array!</span>[[<span class=\"number\">1.</span>, -<span class=\"number\">1.</span>],\n           [<span class=\"number\">2.</span>, -<span class=\"number\">2.</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_rows\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#275-278\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.reserve_rows\" class=\"fn\">reserve_rows</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reserve capacity to grow array by at least <code>additional</code> rows.</p>\n<p>Existing elements of <code>array</code> are untouched and the backing storage is grown by\ncalling the underlying <code>reserve</code> method of the <code>OwnedRepr</code>.</p>\n<p>This is useful when pushing or appending repeatedly to an array to avoid multiple\nallocations.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the resultant capacity is larger than the addressable\nbounds; that is, the product of non-zero axis lengths once <code>axis</code> has been extended by\n<code>additional</code> exceeds <code>isize::MAX</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::Array2;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array2::&lt;i32&gt;::zeros((<span class=\"number\">2</span>,<span class=\"number\">4</span>));\na.reserve_rows(<span class=\"number\">1000</span>).unwrap();\n<span class=\"macro\">assert!</span>(a.into_raw_vec().capacity() &gt;= <span class=\"number\">4</span><span class=\"kw-2\">*</span><span class=\"number\">1002</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_columns\" class=\"method\"><a class=\"src rightside\" href=\"src/ndarray/impl_owned_array.rs.html#298-301\">Source</a><h4 class=\"code-header\">pub fn <a href=\"ndarray/type.Array.html#tymethod.reserve_columns\" class=\"fn\">reserve_columns</a>(&amp;mut self, additional: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"ndarray/struct.ShapeError.html\" title=\"struct ndarray::ShapeError\">ShapeError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reserve capacity to grow array by at least <code>additional</code> columns.</p>\n<p>Existing elements of <code>array</code> are untouched and the backing storage is grown by\ncalling the underlying <code>reserve</code> method of the <code>OwnedRepr</code>.</p>\n<p>This is useful when pushing or appending repeatedly to an array to avoid multiple\nallocations.</p>\n<p><em><strong>Errors</strong></em> with a shape error if the resultant capacity is larger than the addressable\nbounds; that is, the product of non-zero axis lengths once <code>axis</code> has been extended by\n<code>additional</code> exceeds <code>isize::MAX</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>ndarray::Array2;\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = Array2::&lt;i32&gt;::zeros((<span class=\"number\">2</span>,<span class=\"number\">4</span>));\na.reserve_columns(<span class=\"number\">1000</span>).unwrap();\n<span class=\"macro\">assert!</span>(a.into_raw_vec().capacity() &gt;= <span class=\"number\">2</span><span class=\"kw-2\">*</span><span class=\"number\">1002</span>);</code></pre></div>\n</div></details></div></details>",0,"ndarray::aliases::Array2"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CVec%3C%5B%5B%5B%5B%5BA;+J%5D;+K%5D;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+6%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#306\">Source</a><a href=\"#impl-From%3CVec%3C%5B%5B%5B%5B%5BA;+J%5D;+K%5D;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+6%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const M: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const L: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const K: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const J: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; J]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">K</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">L</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;&gt; for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix6.html\" title=\"type ndarray::Ix6\">Ix6</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#306\">Source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(xs: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; J]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">K</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">L</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<Vec<[[[[[A; J]; K]; L]; M]; N]>>","ndarray::aliases::Array6"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CVec%3C%5B%5B%5B%5BA;+K%5D;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+5%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#305\">Source</a><a href=\"#impl-From%3CVec%3C%5B%5B%5B%5BA;+K%5D;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+5%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const M: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const L: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const K: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; K]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">L</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;&gt; for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix5.html\" title=\"type ndarray::Ix5\">Ix5</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#305\">Source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(xs: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; K]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">L</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<Vec<[[[[A; K]; L]; M]; N]>>","ndarray::aliases::Array5"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CVec%3C%5B%5B%5BA;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+4%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#304\">Source</a><a href=\"#impl-From%3CVec%3C%5B%5B%5BA;+L%5D;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+4%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const M: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const L: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; L]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;&gt; for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix4.html\" title=\"type ndarray::Ix4\">Ix4</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#304\">Source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(xs: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; L]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">M</a>]; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<Vec<[[[A; L]; M]; N]>>","ndarray::aliases::Array4"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CVec%3C%5B%5BA;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+3%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#303\">Source</a><a href=\"#impl-From%3CVec%3C%5B%5BA;+M%5D;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+3%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>, const M: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; M]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;&gt; for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix3.html\" title=\"type ndarray::Ix3\">Ix3</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#303\">Source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(xs: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; M]</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">N</a>]&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<Vec<[[A; M]; N]>>","ndarray::aliases::Array3"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CVec%3C%5BA;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+2%5D%3E%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#302\">Source</a><a href=\"#impl-From%3CVec%3C%5BA;+N%5D%3E%3E-for-ArrayBase%3COwnedRepr%3CA%3E,+Dim%3C%5Busize;+2%5D%3E%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; N]</a>&gt;&gt; for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, <a class=\"type\" href=\"ndarray/type.Ix2.html\" title=\"type ndarray::Ix2\">Ix2</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/free_functions.rs.html#302\">Source</a><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(xs: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.90.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.90.0/std/primitive.array.html\">[A; N]</a>&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<Vec<[A; N]>>","ndarray::aliases::Array2"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IntoIterator-for-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/ndarray/iterators/into_iter.rs.html#103-113\">Source</a><a href=\"#impl-IntoIterator-for-ArrayBase%3COwnedRepr%3CA%3E,+D%3E\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;A, D&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a> for <a class=\"type\" href=\"ndarray/type.Array.html\" title=\"type ndarray::Array\">Array</a>&lt;A, D&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"ndarray/trait.Dimension.html\" title=\"trait ndarray::Dimension\">Dimension</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/iterators/into_iter.rs.html#106\">Source</a><a href=\"#associatedtype.Item\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = A</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class=\"toggle\" open><summary><section id=\"associatedtype.IntoIter\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/iterators/into_iter.rs.html#107\">Source</a><a href=\"#associatedtype.IntoIter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" class=\"associatedtype\">IntoIter</a> = <a class=\"struct\" href=\"ndarray/iter/struct.IntoIter.html\" title=\"struct ndarray::iter::IntoIter\">IntoIter</a>&lt;A, D&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_iter\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/ndarray/iterators/into_iter.rs.html#109-112\">Source</a><a href=\"#method.into_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter\" class=\"fn\">into_iter</a>(self) -&gt; Self::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type core::iter::traits::collect::IntoIterator::IntoIter\">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter\">Read more</a></div></details></div></details>","IntoIterator","ndarray::aliases::Array0","ndarray::aliases::Array1","ndarray::aliases::Array2","ndarray::aliases::Array3","ndarray::aliases::Array4","ndarray::aliases::Array5","ndarray::aliases::Array6","ndarray::aliases::ArrayD"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[55724]}